#+TITLE: Communication Interface Report

* Introduction
  Drawbridge will require communication between different components. The
  purpose of this document is to define how they will interact with each other,
  so that a standard can be followed by the programmers. In particular, we are
  defining which protocols will be used.

  This report first presents the data flow, which is organized as sub-sections
  representing a component and sub-sub-sections representing the communication
  actions that module is capable of doing. The second part of the report has
  technical details about TCP and SPI, which are the protocols chosen for
  communication in Drawbridge. TCP will be used for communication with the
  consoles, and SPI - a type of serial communication - for the rest.

* Data Flow
** Input Console
*** Send Backup command
    Follows the Horcrux protocol defined for Drawbridge.
**** TODO Add link for document with Horcrux protocol definition
*** Send Policy Updates with credentials
    The exact policy will be defined in another document.
*** Send Transaction Data to be signed
** Input Data Switch
   A multiplexer is needed after the input data switch, because the ESP-32 only
   has 2 SPI pins.
*** Receive Policy Updates or Transaction Data
*** Forward Policy Updates to Security Engine
*** Forward Transaction Data to Signature Units
** Private Keys Holder
*** Send Private Keys requested by Signature Units
** Signature Units 1 and 2
*** Receive Transaction Data from Input Data Switch
*** Receive Private Keys from Private Keys Holder
    The private keys must be stored in RAM in the signature units. After
    successful signing, the keys must be fully erased.
*** Send Signed Data to Comparison Unit
** Comparison Unit
*** Receive a hash of all signed data from each Signature Unit
*** Request signed data from a Signature Unit
    In case the signed data hashes are equal, the comparison unit then requests
    the full data signed for later forwarding it.
*** Send logs (about the success or failure) to Output Data Switch
*** Forward signed data to Output Data Switch
** Sensors
*** Send sensor data
** Security Engine
*** Receive data from Sensors
    We might have more than one component acting as security engine. For
    instance, the temperature sensors and accelerometers in the lid can be all
    connected to an arduino-like device also casted in concrete, then requiring
    only one wire from this arduino-like device to go into the steel lining.
    This is not required, but allows us to have less wires going into the steel
    lining, making it easier to organize.
*** Receive Policy Updates from Input Data Switch
*** Send destruction flag to KDU
*** Send logs to Output Data Switch
    Logs will included sensor data, security policy changes, info about
    transactions signed for, etc.
** Output Data Switch
*** Receive a signing success/failure flag from Comparison Unit
*** Request signed data from Comparison Unit
    This request happens in case success flag is received.
*** Send logs to Output Console
    Either for success or failure, a log is sent to the output console.
** Output Console
*** Receive logs from Output Data Switch
    In case of failure or success, the console should show a proper message
    indicating so.
*** Receive signed data from Output Data Switch
    This data will be written to an external storage device like an SD Card.
* Communication via Ethernet
** TCP Protocol
    TCP is a connection-oriented protocol, which means a connection is
    established and maintained until the processes at each end have finished
    exchanging messages. The protocol determines how to
    - break application data into packets that networks can deliver,
    - send packets and accepts packets from the network layer,
    - manage flow control, and
    â€” handle retransmission of dropped or garbled packets as well as
      acknowledgment of all packets that arrive, in order to provide error-free
      data transmission
*** How the connection works
    We need to create a server and a client. The server is the one that listens
    for incoming connections on the specified port. On the other side we will
    have a client which can connect to a specified internet IP address and port.

*** Programming
    We will configure the server using [[https://www.arduino.cc/en/Reference/EthernetServer][EthernetServer]] functions. For that we
    just need to define the port.

    To the client we will use [[https://www.arduino.cc/en/Reference/EthernetClient][EthernetClient]] which we need to connect to the
    server and the port available to create the connection itself.

* Communication via Serial
** SPI (Serial Peripheral Interface)
    SPI is a very low power four-wire serial communication interface designed
    for IC controllers and peripherals to communicate with each other. The SPI
    bus is a full-duplex bus, which allows communication to flow to and from the
    master device simultaneously at rates of up to 10Mbps. The high-speed
    operation of SPI generally limits it from being used to communicate between
    components on separate PCBs due to the increase in capacitance that longer
    distance communication adds to the signal lines. PCB capacitance can also
    limit the length of SPI communication lines.

    More information can be found [[https://learn.sparkfun.com/tutorials/serial-peripheral-interface-spi/all#introduction][here]].

*** Summary
**** Advantages of SPI
- It's faster than asynchronous serial
- The receiving hardware can be a simple shift register
- It supports multiple slaves

**** Disadvantages of SPI
- It requires more signal lines (wires) than other communications methods
- The communications must be well-defined in advance (you can't send random
  amounts of data whenever you want)
- The master must control all communications (slaves can't talk directly to
  each other)
- It usually requires separate SS lines to each slave, which can be
  problematic if numerous slaves are needed.
*** How the connection works
In SPI, only one side generates the clock signal (usually called CLK or SCK
for Serial Clock). The side that generates the clock is called the /master/,
and the other side is called the /slave/. There is always only one master
(which is almost always your microcontroller), but there can be multiple
slaves.

When data is sent from the master to a slave, it's sent on a data line called
MOSI ("Master Out / Slave In"). If the slave needs to send a response back to
the master, the master will continue to generate a prearranged number of clock
cycles, and the slave will put the data onto a third data line called MISO
("Master In / Slave Out").

Notice we said "prearranged" in the above description. Because the master
always generates the clock signal, it must know in advance when a slave
needs to return data and how much data will be returned. This is very
different than asynchronous serial, where random amounts of data can be sent
in either direction at any time. In practice this isn't a problem, as SPI is
generally used to talk to sensors that have a very specific command
structure. For example, if you send the command for "read data" to a device,
you know that the device will always send you, for example, two bytes in
return.

In cases where you might want to return a variable amount of data, you could
always return one or two bytes specifying the length of the data and then
have the master retrieve the full amount.

Note that SPI is "full duplex" (has separate send and receive lines), and,
thus, in certain situations, you can transmit and receive data at the same
time (for example, requesting a new sensor reading while retrieving the data
from the previous one). Your device's datasheet will tell you if this is
possible.

*** Programming
- The interface can send data with the most-significant bit (MSB) first, or
  least-significant bit (LSB) first. In the [[https://www.arduino.cc/en/Reference/SPI][Arduino SPI library]], this is
  defined by the [[https://www.arduino.cc/en/Reference/SPISettings][SPISettings]] object.
- The slave will read the data on either the rising edge or the falling edge
  of the clock pulse. Additionally, the clock can be considered "idle" when
  it is high or low. In the [[https://www.arduino.cc/en/Reference/SPI][Arduino SPI library]], this is defined by the
  [[https://www.arduino.cc/en/Reference/SPISettings][SPISettings]] object.
- SPI can operate at extremely high speeds (millions of bytes per second),
  which may be too fast for some devices. To accommodate such devices, you
  can adjust the data rate. In the [[https://www.arduino.cc/en/Reference/SPI][Arduino SPI library]], this is defined by
  the [[https://www.arduino.cc/en/Reference/SPISettings][SPISettings]] object, which divides the master clock (16MHz on most
  Arduinos) down to a frequency between 8MHz (/2) and 125kHz (/128).
- If we are to use the [[https://www.arduino.cc/en/Reference/SPI][SPI Library]], we need to provide the SCK, MOSI and MISO
  pins, as the hardware is hardwired to those pins. There is also a
  dedicated SS pin that we can use (which must, at least, be set to an
  output in order for the SPI hardware to function), but note that we can
  use any other available output pin(s) for SS to your slave device(s) as
  well.
* References

- https://www.digitalocean.com/community/tutorials/an-introduction-to-networking-terminology-interfaces-and-protocols
- https://www.arduino.cc/en/reference/ethernet
- https://medium.com/@araffin/simple-and-robust-computer-arduino-serial-communication-f91b95596788
- https://www.lifewire.com/what-is-an-ethernet-cable-817548
- http://maxembedded.com/2013/09/serial-communication-introduction/#what
- https://www.deviceplus.com/how-tos/arduino-guide/arduino-communication-protocols-tutorial/
- https://www.totalphase.com/blog/2016/06/spi-vs-uart-similarities-differences/
- https://www.elprocus.com/communication-protocols/
- https://www.engineersgarage.com/blogs/comparison-between-serial-communication-protocols-spi-i2c-uartusrt-0
- https://en.wikipedia.org/wiki/Serial_Peripheral_Interface
- https://en.wikipedia.org/wiki/I%C2%B2C
- https://www.arduino.cc/en/Tutorial/SoftwareSerial
- https://www.arduino.cc/en/Tutorial/ArduinoSoftwareRS232
- https://www.arduino.cc/en/reference/SPI
- https://circuitdigest.com/microcontroller-projects/arduino-spi-communication-tutorial
- https://www.codrey.com/embedded-systems/serial-communication-basics/
- https://www.arduino.cc/en/Tutorial/MasterWriter
- https://www.lifewire.com/selecting-between-i2c-and-spi-819003
- https://electronics.stackexchange.com/questions/29037/tradeoffs-when-considering-spi-or-i2c
- https://searchnetworking.techtarget.com/definition/TCP
- https://elementztechblog.wordpress.com/2016/04/10/esp8266-as-tcp-client-for-iot-development-using-raspberry-pi3/
- http://www.linuxhowtos.org/C_C++/socket.htm
- https://learn.sparkfun.com/tutorials/serial-peripheral-interface-spi/all
